# Server.py
import os
import json
import time
import secrets
import asyncio
import subprocess
import threading
from typing import Dict, Any, Tuple, List, Optional
from contextlib import asynccontextmanager

from fastapi import FastAPI, Request, Body
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse

from Comandos import processar_comando
from Database import Database

# ============================================================
# CONFIG BÁSICA
# ============================================================
HTTP_HOST = os.getenv("HTTP_HOST", "0.0.0.0")
HTTP_PORT = int(os.getenv("HTTP_PORT", "5000"))
VERSION_API = "0.0.0.1"

PUBLIC_BASE_URL = os.getenv("PUBLIC_BASE_URL", f"http://127.0.0.1:{HTTP_PORT}")

LAUNCHER_VERSION = "0.0.2"
LAUNCHER_ZIP_NAME = "OBEARCO-Launcher.zip"

GAME_VERSION = "1.0.0"
GAME_ZIP_NAME = "game_v1.0.0.zip"

# ============================================================
# LOBBY UDP (jogadores)
# ============================================================
UDP_BIND_HOST = os.getenv("UDP_BIND_HOST", "0.0.0.0")
UDP_BIND_PORT = int(os.getenv("UDP_BIND_PORT", "7777"))

UDP_PUBLIC_HOST = os.getenv("UDP_PUBLIC_HOST", "127.0.0.1")
UDP_PUBLIC_PORT = int(os.getenv("UDP_PUBLIC_PORT", str(UDP_BIND_PORT)))

# ============================================================
# STATUS JSON + GIT
# ============================================================
DEFAULT_STATUS_DIR = r"C:\Users\Admin\Desktop\Meu_Jogo\meu_launcher\servidor\site-servidor\Servidor"
STATUS_DIR = os.getenv("STATUS_DIR", DEFAULT_STATUS_DIR)
STATUS_FILE_PATH = os.path.join(STATUS_DIR, "server_status.json")
GIT_REMOTE_NAME = os.getenv("GIT_REMOTE_NAME", "origin")


def _write_status_json(status_servidor: str) -> None:
    os.makedirs(STATUS_DIR, exist_ok=True)

    data = {
        "url_api_base": PUBLIC_BASE_URL,
        "porta": HTTP_PORT,
        "status_servidor": status_servidor,
        "version_api": VERSION_API,
        "LAUCHER": {
            "current_version": LAUNCHER_VERSION,
            "update_zip_name": LAUNCHER_ZIP_NAME,
        },
        "GAME": {
            "current_version": GAME_VERSION,
            "update_zip_name": GAME_ZIP_NAME,
        },
        "UDP_LOBBY": {"host": UDP_PUBLIC_HOST, "port": UDP_PUBLIC_PORT},
    }

    with open(STATUS_FILE_PATH, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=4, ensure_ascii=False)

    print(f"[STATUS] Atualizado: {STATUS_FILE_PATH} -> {status_servidor}")
    print(f"[STATUS] url_api_base = {PUBLIC_BASE_URL}")


def _git_push_status(commit_message: str) -> None:
    repo_path = STATUS_DIR
    filename = os.path.basename(STATUS_FILE_PATH)

    if not os.path.isdir(repo_path):
        print(f"[GIT] STATUS_DIR não existe: {repo_path}")
        return

    try:
        subprocess.run(["git", "add", filename], cwd=repo_path, check=True)

        commit_result = subprocess.run(
            ["git", "commit", "-m", commit_message],
            cwd=repo_path,
            check=False,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
        )

        if "nothing to commit" in (commit_result.stdout or ""):
            print("[GIT] Nada para commitar.")
            return

        branch_result = subprocess.run(
            ["git", "rev-parse", "--abbrev-ref", "HEAD"],
            cwd=repo_path,
            check=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
        )
        branch = branch_result.stdout.strip()

        subprocess.run(["git", "push", GIT_REMOTE_NAME, branch], cwd=repo_path, check=True)
        print("[GIT] Push OK.")
    except Exception as e:
        print(f"[GIT] ERRO: {e}")


def update_status_and_push(status: str) -> None:
    _write_status_json(status)
    msg = f"STATUS: Servidor {status.upper()} - {PUBLIC_BASE_URL}"
    _git_push_status(msg)


# ============================================================
# DB + SESSÕES
# ============================================================
db_connection: Database | None = None

SESSION_TTL = 60 * 60 * 24 * 7  # 7 dias
SESSIONS: Dict[str, Dict[str, Any]] = {}


def _create_session(email: str, usuario: str | None, ip: str | None, ua: str | None) -> str:
    now_ts = time.time()
    token: str | None = None

    if db_connection and getattr(db_connection, "is_connected", lambda: False)():
        try:
            fn = getattr(db_connection, "create_session", None)
            if callable(fn):
                sess_result = fn(email=email, ip=ip or "", ua=ua or "", ttl_seconds=SESSION_TTL)
                if isinstance(sess_result, dict) and sess_result.get("ok"):
                    token = sess_result.get("token")
        except Exception as e:
            print(f"[SESSION] Exceção ao criar sessão no DB: {e}")

    if not token:
        token = secrets.token_hex(32)

    SESSIONS[token] = {
        "email": email,
        "usuario": usuario or "",
        "created_ts": now_ts,
        "ip": ip or "",
        "ua": ua or "",
    }

    print(f"[SESSION] criada para {email}: {token}")
    return token


def _get_session(token: str | None) -> Dict[str, Any] | None:
    if not token:
        return None

    now_ts = time.time()

    data = SESSIONS.get(token)
    if data:
        if now_ts - data.get("created_ts", 0) <= SESSION_TTL:
            return data
        SESSIONS.pop(token, None)

    if db_connection and getattr(db_connection, "is_connected", lambda: False)():
        fn = getattr(db_connection, "get_valid_session", None)
        if callable(fn):
            try:
                db_data = fn(token=token, ttl_seconds=SESSION_TTL)
                if db_data:
                    mapped = {
                        "email": db_data.get("email"),
                        "usuario": db_data.get("usuario", ""),
                        "created_ts": db_data.get("created_at", now_ts),
                        "ip": db_data.get("ip", ""),
                        "ua": db_data.get("ua", ""),
                    }
                    SESSIONS[token] = mapped
                    return mapped
            except Exception as e:
                print(f"[SESSION] Erro ao carregar sessão do DB: {e}")

    return None


def _get_password(body: Dict[str, Any]) -> str:
    return (body.get("password") or body.get("senha") or body.get("pass") or "").strip()


# ============================================================
# UDP LOBBY
# ============================================================
class LobbyProtocol(asyncio.DatagramProtocol):
    def connection_made(self, transport):
        self.transport = transport
        print(
            f"[UDP] Lobby escutando em {UDP_BIND_HOST}:{UDP_BIND_PORT} "
            f"(publicado como {UDP_PUBLIC_HOST}:{UDP_PUBLIC_PORT})"
        )

    def datagram_received(self, data, addr):
        msg = data.decode("utf-8", errors="ignore").strip()
        print(f"[UDP] {addr} -> {msg}")
        self.transport.sendto(b"OK", addr)


_udp_task: asyncio.Task | None = None


async def start_udp_lobby() -> None:
    loop = asyncio.get_running_loop()
    transport, _protocol = await loop.create_datagram_endpoint(
        lambda: LobbyProtocol(),
        local_addr=(UDP_BIND_HOST, UDP_BIND_PORT),
    )
    try:
        await asyncio.Future()
    finally:
        transport.close()
        print("[UDP] Lobby encerrado.")


async def stop_udp_lobby() -> None:
    global _udp_task
    if _udp_task:
        _udp_task.cancel()
        try:
            await _udp_task
        except asyncio.CancelledError:
            pass
        _udp_task = None


# ============================================================
# CLOUDFLARE TUNNEL (trycloudflare)
# ============================================================
CLOUDFLARED_PATH = os.getenv("CLOUDFLARED_PATH", "cloudflared")
_cf_process: subprocess.Popen | None = None


def _start_cloudflare_tunnel():
    global _cf_process, PUBLIC_BASE_URL

    if _cf_process is not None and _cf_process.poll() is None:
        print("[CF] Já existe um cloudflared rodando.")
        return

    try:
        cmd = [
            CLOUDFLARED_PATH,
            "tunnel",
            "--url",
            f"http://127.0.0.1:{HTTP_PORT}",
            "--no-autoupdate",
        ]
        print(f"[CF] Iniciando Cloudflare Tunnel: {' '.join(cmd)}")
        _cf_process = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            bufsize=1,
        )
    except FileNotFoundError:
        print("[CF] ERRO: 'cloudflared' não encontrado.")
        return
    except Exception as e:
        print(f"[CF] ERRO ao iniciar cloudflared: {e}")
        return

    def _reader():
        global PUBLIC_BASE_URL
        if not _cf_process or not _cf_process.stdout:
            return

        for line in _cf_process.stdout:
            line = line.rstrip("\n")
            print(f"[CF] {line}")
            if "trycloudflare.com" in line and "https://" in line:
                start = line.find("https://")
                end = line.find(" ", start)
                if end == -1:
                    end = len(line)
                url = line[start:end].strip()
                if url:
                    PUBLIC_BASE_URL = url
                    print(f"[CF] URL do túnel detectada: {PUBLIC_BASE_URL}")
                    update_status_and_push("Online")

    threading.Thread(target=_reader, daemon=True).start()


def _stop_cloudflare_tunnel():
    global _cf_process
    if _cf_process is None:
        return
    if _cf_process.poll() is not None:
        _cf_process = None
        return

    print("[CF] Encerrando cloudflared...")
    try:
        _cf_process.terminate()
        _cf_process.wait(timeout=10)
    except Exception as e:
        print(f"[CF] Erro ao encerrar cloudflared: {e}")
    finally:
        _cf_process = None


# ============================================================
# FASTAPI + LIFESPAN
# ============================================================
async def on_startup():
    global db_connection, _udp_task
    print("[STARTUP] Iniciando servidor...")

    try:
        db_connection = Database()
        print("[DB] Conectado.")
    except Exception as e:
        db_connection = None
        print(f"[DB] ERRO: {e}")

    _udp_task = asyncio.create_task(start_udp_lobby())

    update_status_and_push("Online")
    _start_cloudflare_tunnel()


async def on_shutdown():
    global db_connection
    print("[SHUTDOWN] Encerrando servidor...")

    await stop_udp_lobby()
    _stop_cloudflare_tunnel()

    if db_connection and hasattr(db_connection, "close"):
        try:
            db_connection.close()
            print("[DB] Conexão fechada.")
        except Exception as e:
            print(f"[DB] Erro ao fechar: {e}")
    db_connection = None

    update_status_and_push("Offline")


@asynccontextmanager
async def lifespan(app: FastAPI):
    await on_startup()
    try:
        yield
    finally:
        await on_shutdown()


app = FastAPI(lifespan=lifespan)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ============================================================
# HELPER DE COMANDOS (DB)
# ============================================================
def _check_db_and_process(data: Dict[str, Any], command: str) -> Tuple[Dict[str, Any], int]:
    global db_connection

    if not db_connection or not getattr(db_connection, "is_connected", lambda: False)():
        return (
            {"error": "Servidor temporariamente indisponível. Falha na conexão com o Banco de Dados."},
            503,
        )

    if not isinstance(data, dict):
        return ({"error": "Payload inválido. JSON deve ser um objeto."}, 400)

    data["comando"] = command

    try:
        print(f"[CMD] => {json.dumps(data, ensure_ascii=False)}")
        resp = processar_comando(db_connection, data)
    except Exception as e:
        print(f"[CMD] ERRO processar_comando: {e}")
        return ({"error": "Erro interno ao processar comando."}, 500)

    if not isinstance(resp, dict):
        resp = {"result": resp}

    print(f"[CMD] <= {resp}")
    code = 200 if "error" not in resp else 400
    return resp, code


# ============================================================
# ROTAS HTTP
# ============================================================
@app.get("/api/status")
def api_status():
    return {
        "status": "Online",
        "version_api": VERSION_API,
        "url_api_base": PUBLIC_BASE_URL,
        "udp_lobby": {"host": UDP_PUBLIC_HOST, "port": UDP_PUBLIC_PORT},
    }


# -------- AUTH (site usa essas) --------
@app.post("/api/auth/login")
def api_auth_login(request: Request, body: Dict[str, Any] = Body(default_factory=dict)):
    email = (body.get("email") or "").strip()
    senha = _get_password(body)

    ip = request.client.host if request.client else ""
    ua = request.headers.get("User-Agent", "")

    data_cmd = {"email": email, "senha": senha, "ip": ip, "ua": ua}
    resp, status = _check_db_and_process(data_cmd, "/login")

    if "error" in resp or status != 200:
        return JSONResponse(status_code=401, content={"ok": False, "error": resp.get("error", "Erro de login")})

    usuario = (resp.get("usuario") or "").strip() or (email.split("@")[0] if "@" in email else email)
    token = _create_session(email, usuario, ip, ua)
    return {"ok": True, "user_id": email, "usuario": usuario, "session_token": token}


@app.post("/api/auth/register")
def api_auth_register(request: Request, body: Dict[str, Any] = Body(default_factory=dict)):
    email = (body.get("email") or "").strip()
    senha = _get_password(body)
    usuario = (body.get("usuario") or "").strip()

    if not usuario and "@" in email:
        usuario = email.split("@", 1)[0]

    data_cmd = {"email": email, "senha": senha, "usuario": usuario}
    resp, status = _check_db_and_process(data_cmd, "/register")

    if "error" in resp or status != 200:
        return JSONResponse(status_code=400, content={"ok": False, "error": resp.get("error", "Erro ao registrar")})

    ip = request.client.host if request.client else ""
    ua = request.headers.get("User-Agent", "")
    token = _create_session(email, usuario, ip, ua)

    return {"ok": True, "user_id": email, "usuario": usuario, "session_token": token, "message": resp.get("message", "")}


@app.post("/api/auth/validate")
def api_auth_validate(body: Dict[str, Any] = Body(default_factory=dict)):
    token = (body.get("session_token") or "").strip()
    sess = _get_session(token)
    if not sess:
        return JSONResponse(status_code=401, content={"ok": False})
    return {"ok": True, "user_id": sess["email"], "usuario": sess.get("usuario", "")}


# -------- COMPAT (pra quem ainda chama /login e /register direto) --------
@app.post("/login")
def compat_login(request: Request, body: Dict[str, Any] = Body(default_factory=dict)):
    # aceita senha/password
    email = (body.get("email") or "").strip()
    senha = _get_password(body)

    ip = request.client.host if request.client else ""
    ua = request.headers.get("User-Agent", "")

    data_cmd = {"email": email, "senha": senha, "ip": ip, "ua": ua}
    resp, status = _check_db_and_process(data_cmd, "/login")
    if "error" in resp or status != 200:
        return JSONResponse(status_code=401, content={"ok": False, "error": resp.get("error", "Erro de login")})

    usuario = (resp.get("usuario") or "").strip() or (email.split("@")[0] if "@" in email else email)
    token = _create_session(email, usuario, ip, ua)
    return {"ok": True, "user_id": email, "usuario": usuario, "session_token": token}


@app.post("/register")
def compat_register(request: Request, body: Dict[str, Any] = Body(default_factory=dict)):
    email = (body.get("email") or "").strip()
    senha = _get_password(body)
    usuario = (body.get("usuario") or "").strip()

    if not usuario and "@" in email:
        usuario = email.split("@", 1)[0]

    data_cmd = {"email": email, "senha": senha, "usuario": usuario}
    resp, status = _check_db_and_process(data_cmd, "/register")
    if "error" in resp or status != 200:
        return JSONResponse(status_code=400, content={"ok": False, "error": resp.get("error", "Erro ao registrar")})

    ip = request.client.host if request.client else ""
    ua = request.headers.get("User-Agent", "")
    token = _create_session(email, usuario, ip, ua)

    return {"ok": True, "user_id": email, "usuario": usuario, "session_token": token, "message": resp.get("message", "")}


# -------- FEED (site usa isso) --------
def _normalize_char_list(chars: Any) -> List[Dict[str, str]]:
    if not isinstance(chars, list):
        return []
    out: List[Dict[str, str]] = []
    for c in chars:
        if isinstance(c, str):
            out.append({"nick": c})
        elif isinstance(c, dict):
            nick = c.get("nick") or c.get("nome") or c.get("name") or "Personagem"
            out.append({"nick": str(nick)})
        else:
            out.append({"nick": "Personagem"})
    return out


def _auto_feed_from_pymongo() -> Optional[List[Dict[str, Any]]]:
    """
    Tenta montar o feed automaticamente se Database expõe .db (pymongo database).
    Não é garantido, mas ajuda MUITO sem mexer em Database.py.
    """
    if not db_connection:
        return None

    db = getattr(db_connection, "db", None) or getattr(db_connection, "database", None)
    if db is None:
        return None

    list_cols = getattr(db, "list_collection_names", None)
    if not callable(list_cols):
        return None

    try:
        cols = set(list_cols())
    except Exception:
        return None

    user_candidates = ["users", "usuarios", "accounts", "contas", "user", "account"]
    char_candidates = ["personagens", "characters", "chars", "saves", "players", "profiles"]

    user_col = next((c for c in user_candidates if c in cols), None)
    char_col = next((c for c in char_candidates if c in cols), None)

    if not user_col:
        return None

    users_coll = db[user_col]
    chars_coll = db[char_col] if char_col else None

    users: List[Dict[str, Any]] = []
    try:
        # busca leve
        cursor = users_coll.find({}, {"email": 1, "usuario": 1, "nick": 1, "username": 1, "personagens": 1, "characters": 1}).limit(500)
        for doc in cursor:
            email = doc.get("email") or doc.get("user_id") or doc.get("id") or ""
            if not email and isinstance(doc.get("_id"), str):
                email = doc["_id"]

            usuario = doc.get("usuario") or doc.get("username") or doc.get("nick") or ""
            if not usuario and isinstance(email, str) and "@" in email:
                usuario = email.split("@", 1)[0]
            if not usuario:
                usuario = "user"

            embedded = doc.get("personagens") or doc.get("characters")
            personagens = _normalize_char_list(embedded)

            # se não tem embedded, tenta buscar em outra collection
            if not personagens and chars_coll and isinstance(email, str) and email:
                q_list = [
                    {"email": email},
                    {"user_id": email},
                    {"owner_email": email},
                    {"owner": email},
                    {"uid": email},
                ]
                found = []
                for q in q_list:
                    try:
                        found = list(chars_coll.find(q, {"nick": 1, "nome": 1, "name": 1}).limit(50))
                        if found:
                            break
                    except Exception:
                        pass
                personagens = _normalize_char_list(found)

            users.append({"user_id": email, "usuario": usuario, "personagens": personagens})
    except Exception:
        return None

    return users


@app.get("/api/social/users")
def api_social_users():
    """
    Retorna:
    { ok: true, users: [ {user_id,email/uid, usuario, personagens:[{nick}]} ] }
    """
    global db_connection

    if not db_connection or not getattr(db_connection, "is_connected", lambda: False)():
        return JSONResponse(status_code=503, content={"ok": False, "error": "DB offline"})

    # 1) Se você implementar no Database.py, aqui vira perfeito:
    fn = getattr(db_connection, "list_users_with_characters", None)
    if callable(fn):
        try:
            users = fn()
            return {"ok": True, "users": users}
        except Exception as e:
            print(f"[FEED] Erro list_users_with_characters(): {e}")

    # 2) tenta auto-montar via pymongo (se existir .db)
    users_auto = _auto_feed_from_pymongo()
    if users_auto is not None:
        return {"ok": True, "users": users_auto}

    # 3) fallback via comandos (se você criar /social/users no Comandos.py)
    resp, status = _check_db_and_process({}, "/social/users")
    if status != 200 or "error" in resp:
        return JSONResponse(
            status_code=501,
            content={"ok": False, "error": "Implemente Database.list_users_with_characters() OU exponha db_connection.db (pymongo) OU crie comando /social/users"},
        )

    users = resp.get("users") or resp.get("result") or []
    return {"ok": True, "users": users}


# ============================================================
# OUTROS ENDPOINTS (mantidos)
# ============================================================
@app.post("/api/game/save")
def api_game_save(body: Dict[str, Any] = Body(default_factory=dict)):
    token = (body.get("session_token") or "").strip()
    sess = _get_session(token)
    if not sess:
        return JSONResponse(status_code=401, content={"ok": False, "error": "Sessão inválida"})

    entries = body.get("data") or []
    email = sess["email"]
    print(f"[SAVE] {email} -> {entries}")
    return {"ok": True}


@app.post("/api/cmd")
def api_cmd(body: Dict[str, Any] = Body(default_factory=dict)):
    command = body.get("comando", "comando-desconhecido")
    resp, status = _check_db_and_process(body, command)
    return JSONResponse(status_code=status, content=resp)


# ============================================================
# ENTRY POINT
# ============================================================
if __name__ == "__main__":
    import uvicorn
    uvicorn.run("Server:app", host=HTTP_HOST, port=HTTP_PORT, reload=False, workers=1)
